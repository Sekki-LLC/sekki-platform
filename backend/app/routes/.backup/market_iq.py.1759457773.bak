from __future__ import annotations
import os, json, time, uuid, sqlite3, re
from typing import Dict, Any, Optional, List
from flask import Blueprint, request, jsonify, current_app

# ---------- blueprint ----------
market_iq_bp = Blueprint("market_iq", __name__, url_prefix="/api/market-iq")

# ---------- storage ----------
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))  # .../backend
RUNTIME_DIR = os.path.join(BASE_DIR, "runtime")
os.makedirs(RUNTIME_DIR, exist_ok=True)
DB_PATH = os.environ.get("MIQ_DB_PATH", os.path.join(RUNTIME_DIR, "miq_sessions.sqlite3"))

def _db():
    con = sqlite3.connect(DB_PATH)
    con.row_factory = sqlite3.Row
    con.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
      id TEXT PRIMARY KEY,
      description TEXT NOT NULL,
      answers_json TEXT NOT NULL,
      answered_q INTEGER NOT NULL,
      total_q INTEGER NOT NULL,
      last_field TEXT,
      created_at INTEGER NOT NULL
    )
    """)
    return con

def _new_id() -> str:
    return f"miq_{uuid.uuid4().hex[:10]}"

def _load(sid: str) -> Optional[Dict[str, Any]]:
    with _db() as con:
        cur = con.execute("SELECT * FROM sessions WHERE id=?", (sid,))
        row = cur.fetchone()
        if not row:
            return None
        return {
            "id": row["id"],
            "description": row["description"],
            "answers": json.loads(row["answers_json"]),
            "answered_q": int(row["answered_q"]),
            "total_q": int(row["total_q"]),
            "last_field": row["last_field"],
            "created_at": int(row["created_at"]),
        }

def _save(sess: Dict[str, Any]) -> None:
    with _db() as con:
        con.execute("""
        INSERT INTO sessions (id, description, answers_json, answered_q, total_q, last_field, created_at)
        VALUES (?,?,?,?,?,?,?)
        ON CONFLICT(id) DO UPDATE SET
          description=excluded.description,
          answers_json=excluded.answers_json,
          answered_q=excluded.answered_q,
          total_q=excluded.total_q,
          last_field=excluded.last_field
        """, (
            sess["id"],
            sess["description"],
            json.dumps(sess["answers"], ensure_ascii=False),
            int(sess["answered_q"]),
            int(sess["total_q"]),
            sess.get("last_field"),
            int(sess.get("created_at") or int(time.time())),
        ))

# ---------- interview plan (coverage only; LLM writes wording) ----------
FIELD_ORDER: List[str] = [
    "primary_goal", "initiative", "customer", "geo", "market_size",
    "budget", "timeline", "pricing", "kpi", "risks",
    "moat", "channels", "resources", "compliance", "data", "success",
]
ALLOWED_FIELDS = set(FIELD_ORDER)

def _select_next(answers: Dict[str, Any]) -> Optional[str]:
    for f in FIELD_ORDER:
        if f not in answers:
            return f
    return None

def _label(f: Optional[str]) -> str:
    return "project" if not f else f.replace("_", " ")

# ---------- LLM wiring ----------
def _env_bool(name: str, default: bool=False) -> bool:
    v = os.environ.get(name, "")
    return (str(v).lower() in ("1","true","yes","on")) if v != "" else default

MIQ_USE_LLM = _env_bool("MIQ_USE_LLM", False)
MIQ_MODEL = os.environ.get("MIQ_MODEL", "gpt-4o-mini")
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", "")

SYSTEM_PROMPT = f"""
You are a senior operator interviewing a business user to evaluate a project.
Be warm, concise, and practical. Ask ONE question at a time.
Never re-ask fields that are already answered. Allowed fields:
{", ".join(FIELD_ORDER)}.

Goals:
- Phrase questions naturally, mirroring the user's wording when helpful.
- If the user's last answer is vague, ask a focused clarifying follow-up.
- Stop when enough fields are covered for an initial scoring pass.

Return STRICT JSON ONLY (no prose), shape:
{{
  "action": "ask" | "clarify" | "finalize",
  "next_field": "<one of the allowed fields or null>",
  "question": "<your single next question text or null>",
  "added": {{ "<field>": "<value>", ... }},
  "confidence": <number 0..1>
}}
"""

def _strip_json_block(text: str) -> str:
    m = re.search(r"```json\s*(\{.*\})\s*```", text, re.S)
    if m: return m.group(1)
    m = re.search(r"```(?:\w+)?\s*(\{.*\})\s*```", text, re.S)
    if m: return m.group(1)
    return text.strip()

def llm_step(description: str,
             answers: Dict[str, Any],
             latest_text: Optional[str],
             remaining_fields: List[str]) -> Optional[Dict[str, Any]]:
    if not (MIQ_USE_LLM and OPENAI_API_KEY):
        return None
    try:
        try:
            import httpx  # lazy import so missing httpx won't crash boot
        except Exception:
            current_app.logger.warning("httpx not available; skipping LLM.")
            return None

        user_payload = {
            "context": {
                "description": description,
                "answers": answers,
                "remaining_fields": remaining_fields,
            },
            "latest_user_text": latest_text,
        }

        with httpx.Client(timeout=20.0) as client:
            r = client.post(
                "https://api.openai.com/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {OPENAI_API_KEY}",
                    "Content-Type": "application/json",
                },
                json={
                    "model": MIQ_MODEL,
                    "temperature": float(os.environ.get("MIQ_TEMPERATURE", "0.4")),
                    "messages": [
                        {"role": "system", "content": SYSTEM_PROMPT},
                        {"role": "user", "content": json.dumps(user_payload, ensure_ascii=False)},
                    ],
                },
            )
        r.raise_for_status()
        content = r.json()["choices"][0]["message"]["content"]
        raw = _strip_json_block(content)
        data = json.loads(raw)

        next_field = data.get("next_field")
        if next_field and next_field not in ALLOWED_FIELDS:
            next_field = _select_next(answers)

        question = data.get("question")
        if not isinstance(question, str) or not question.strip():
            question = None

        added = data.get("added") or {}
        if not isinstance(added, dict):
            added = {}

        return {
            "action": data.get("action") or "ask",
            "next_field": next_field,
            "question": question,
            "next_question": question,  # alias for older callers
            "added": added,
            "confidence": float(data.get("confidence") or 0.0),
            "finalize": data.get("action") == "finalize",
        }
    except Exception as e:
        current_app.logger.exception("llm_step error: %s", e)
        return None

# ---------- minimal scoring (placeholder) ----------
def _score_from_answers(answers: Dict[str, Any]) -> int:
    covered = sum(1 for f in FIELD_ORDER if f in answers)
    base = 40 + min(50, covered * 3)
    txt = " ".join(map(str, answers.values())).lower()
    for kw in ("roi", "irr", "npv", "ebitda", "payback", "risk", "market size", "timeline"):
        if kw in txt:
            base += 2
    return max(10, min(99, base))

def _analysis_result(sess: Dict[str, Any]) -> Dict[str, Any]:
    score = _score_from_answers(sess["answers"])
    return {
        "market_iq_score": score,
        "summary": "Initial Market IQ summary generated from your intake answers.",
        "component_scores": {
            "market": min(100, score + 2),
            "product": max(0, score - 5),
            "execution": min(100, score),
            "risk": max(0, 100 - score),
        },
        "answers": sess["answers"],
    }

# ---------- routes ----------
@market_iq_bp.route("/intake/start", methods=["POST"])
def intake_start():
    data = request.get_json(silent=True) or {}
    description = (data.get("description") or "").strip()
    if not description:
        return jsonify({"error": "description_required"}), 400

    sid = _new_id()
    sess = {
        "id": sid,
        "description": description,
        "answers": {},
        "answered_q": 0,
        "total_q": len(FIELD_ORDER),
        "last_field": None,
        "created_at": int(time.time()),
    }

    remaining = [f for f in FIELD_ORDER if f not in sess["answers"]]
    step = llm_step(description, sess["answers"], None, remaining)

    next_field = step["next_field"] if step else (remaining[0] if remaining else None)
    question = (step.get("question") if step else None) or (
        f"To begin, tell me about your {_label(next_field)}."
    )

    sess["last_field"] = next_field
    _save(sess)

    return jsonify({
        "analysis_id": sid,
        "field": next_field,
        "question": question,
        "answered": sess["answered_q"],
        "total_questions": sess["total_q"],
    })

@market_iq_bp.route("/intake/answer", methods=["POST"])
def intake_answer():
    data = request.get_json(silent=True) or {}
    sid = data.get("analysis_id")
    user_text = (data.get("answer") or "").strip()
    explicit_field = data.get("field")

    if not sid or not user_text:
        return jsonify({"error": "missing_params"}), 400
    sess = _load(sid)
    if not sess:
        return jsonify({"error": "unknown_analysis_id"}), 404

    answers = sess["answers"]

    # Record explicit field if provided
    if explicit_field and explicit_field in ALLOWED_FIELDS and explicit_field not in answers:
        answers[explicit_field] = user_text
        sess["answered_q"] += 1

    remaining = [f for f in FIELD_ORDER if f not in answers]
    step = llm_step(sess["description"], answers, user_text, remaining)

    # Ingest any fields the model extracted
    added = (step.get("added") if step else {}) or {}
    added_count = 0
    for k, v in added.items():
        if k in ALLOWED_FIELDS and k not in answers and isinstance(v, str) and v.strip():
            answers[k] = v.strip()
            added_count += 1
    if added_count:
        sess["answered_q"] += added_count

    # Recompute remaining
    remaining = [f for f in FIELD_ORDER if f not in answers]

    # Finalize if model says so OR nothing left
    should_finalize = (step and step.get("finalize")) or (len(remaining) == 0)
    if should_finalize:
        _save(sess)
        return jsonify({
            "complete": True,
            "analysis_result": _analysis_result(sess),
            "answered": sess["answered_q"],
            "total_questions": sess["total_q"],
        })

    next_field = (step.get("next_field") if step else None) or (remaining[0] if remaining else None)
    question = (step.get("question") if step else None) or (
        f"Could you share more about your {_label(next_field)}?"
    )

    sess["last_field"] = next_field
    _save(sess)

    return jsonify({
        "complete": False,
        "next_field": next_field,
        "next_question": question,
        "answered": sess["answered_q"],
        "total_questions": sess["total_q"],
    })

# Basic stubs to avoid 404s for callers
@market_iq_bp.route("/analyze", methods=["POST"])
def analyze():
    data = request.get_json(silent=True) or {}
    sid = data.get("analysis_id")
    sess = _load(sid) if sid else None
    if not sess:
        return jsonify({"error": "unknown_analysis_id"}), 404
    return jsonify(_analysis_result(sess))

@market_iq_bp.route("/scenario", methods=["POST"])
def scenario():
    data = request.get_json(silent=True) or {}
    base = data.get("analysis_result") or {}
    changes = data.get("changes") or {}
    out = dict(base)
    out["scenario_applied"] = changes
    delta = int(changes.get("delta", 0)) if isinstance(changes.get("delta", 0), (int, str)) else 0
    out["market_iq_score"] = max(1, min(99, int(base.get("market_iq_score", 70)) + int(delta)))
    return jsonify(out)
