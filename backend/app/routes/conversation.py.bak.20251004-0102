from __future__ import annotations
import json, os, re, time, uuid
from pathlib import Path
from typing import Dict, List, Tuple
from flask import Blueprint, request, jsonify, current_app

try:
    from anthropic import Anthropic
except Exception:
    Anthropic = None

conversation_bp = Blueprint("conversation", __name__)

ANTHROPIC_MODEL = os.getenv("ANTHROPIC_MODEL", "claude-3-5-sonnet-latest")
SESS_DIR = Path(os.getenv("SESSION_DIR", Path(__file__).resolve().parents[2] / "runtime" / "sessions"))
SESS_DIR.mkdir(parents=True, exist_ok=True)

SLOTS = ("target","problem","solution","budget","timeline","channel","risks","kpi","constraints")
WEIGHTS = {"target":2.0,"problem":2.0,"solution":1.8,"budget":1.2,"timeline":1.2,"channel":1.0,"risks":1.0,"kpi":0.8,"constraints":0.6}

CLIENT = Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY")) if (Anthropic and os.getenv("ANTHROPIC_API_KEY")) else None

def _norm(s: str) -> str: return " ".join((s or "").lower().split())
def _sess_path(sid: str) -> Path: return SESS_DIR / f"{sid}.json"
def _load_session(sid: str) -> Dict:
    p = _sess_path(sid)
    if p.exists():
        try: return json.loads(p.read_text())
        except Exception: return {}
    return {}
def _save_session(sid: str, data: Dict) -> None:
    tmp = _sess_path(f"{sid}.{int(time.time()*1000)}.tmp")
    tmp.write_text(json.dumps(data, ensure_ascii=False))
    tmp.rename(_sess_path(sid))

def _strip_lists(text: str) -> str:
    if not text: return ""
    lines = [ln for ln in text.splitlines() if not re.match(r"^\s*([•\-*]|\d+\.)\s", ln)]
    text = " ".join(ln.strip() for ln in lines if ln.strip())
    return re.sub(r"\s+", " ", text).strip()

def _ensure_two_sentences_one_question(text: str, fallback_question: str) -> str:
    txt = _strip_lists(text)
    parts = re.split(r"(?<=[.!?])\s+", txt)
    if len(parts) > 2: txt = " ".join(parts[:2])
    if "?" not in txt:
        q = fallback_question.rstrip("?") + "?"
        txt = (txt + " " + q).strip() if txt else q
    segs = txt.split("?")
    if len(segs) > 2:
        txt = "?".join([" ".join(segs[:-1]).replace("?", ".")] + [segs[-1]])
        if not txt.endswith("?"): txt = txt.rstrip(". ") + "?"
    if len(txt) > 480: txt = txt[:470].rstrip() + "?"
    return txt

def _dedupe_against_last(history: List[Dict[str,str]], reply: str) -> str:
    last_ai = next((m for m in reversed(history) if m.get("role") == "assistant"), None)
    if last_ai and _norm(last_ai.get("content","")) == _norm(reply):
        reply = reply.rstrip("?") + " — could you clarify that last point?"
    return reply

def _extract_slots(text: str) -> Dict[str,str]:
    t = " " + _norm(text) + " "
    out = {k: None for k in SLOTS}
    m = re.search(r"(smb|mid[- ]market|enterprise|consumers?|buyers?|it|ops|finance|marketing|sales|developers?)", t)
    if m: out["target"] = m.group(0)
    m = re.search(r"(pain|problem|churn|latency|downtime|compliance|cost overrun|support|ticket|inefficien|bottleneck)", t)
    if m: out["problem"] = m.group(0)
    m = re.search(r"(saas|platform|tool|api|service|app|analytics|agent|automation|market iq)", t)
    if m: out["solution"] = m.group(0)
    m = re.search(r"\b(\$?\d+(\.\d+)?\s*(k|m|mm)|budget)\b", t)
    if m: out["budget"] = m.group(0)
    m = re.search(r"(q[1-4]\s*\d{4}|\b\d+\s*(weeks?|months?|quarters?|years?)\b|\bby\s+\w+\s+\d{4}\b)", t)
    if m: out["timeline"] = m.group(0)
    m = re.search(r"(paid|organic|seo|sem|ads?|sales|partners?|resellers?|marketplace|email|social|events?)", t)
    if m: out["channel"] = m.group(0)
    m = re.search(r"(risk|dependency|constraint|capex|capability|regulatory|privacy|gdpr|security)", t)
    if m: out["risks"] = m.group(0)
    m = re.search(r"(roi|payback|ltv|cac|mrr|arr|ebitda|retention|conversion|nps)", t)
    if m: out["kpi"] = m.group(0)
    m = re.search(r"(hiring|data access|integration|budget ceiling|timeline limit|compliance gate)", t)
    if m: out["constraints"] = m.group(0)
    return out

def _readiness(slots: Dict[str,str]) -> int:
    score, max_score = 0.0, sum(WEIGHTS.values())
    for k,w in WEIGHTS.items():
        score += w * (1.0 if slots.get(k) else 0.0)
    return max(0, min(100, round(100 * (score / max_score))))

def _next_question(slots: Dict[str,str]) -> Tuple[str,str]:
    missing = [k for k in SLOTS if not slots.get(k)]
    if not missing:
        return ("risks", "What’s the most material risk to the plan and how would you mitigate it?")
    top = sorted(missing, key=lambda k: WEIGHTS[k], reverse=True)[0]
    q_map = {
        "target": "Who exactly is the buyer (role/company size/industry) and what job are they hiring you to do?",
        "problem": "What painful, measurable problem do they have today and how do they handle it now?",
        "solution": "Briefly, what’s the solution’s core mechanism of value versus status quo?",
        "budget": "What total budget (order of magnitude) can you commit over the next 6–12 months?",
        "timeline": "What’s the target go-live date or time window you’re driving toward?",
        "channel": "Which acquisition channel will likely yield the first scalable traction?",
        "risks": "What’s the most material risk to the plan and how would you mitigate it?",
        "kpi": "What single KPI will define success at the end of this phase?",
        "constraints": "What hard constraints (team, data access, compliance) could block progress?",
    }
    return (top, q_map[top])

def _analyst_context(slots: Dict[str,str]) -> str:
    known = ", ".join(f"{k}={v}" for k,v in slots.items() if v) or "—"
    missing = ", ".join(k for k in SLOTS if not slots.get(k)) or "—"
    return f"Known: {known}. Missing: {missing}."

SYSTEM_HEAD = (
    "You are a top 0.1% market analyst. Be surgical and assumption-aware. "
    "Provide at most two crisp sentences tailored to the user's latest input, "
    "then ask exactly one high-leverage follow-up. No lists or outlines."
)

def _ask_with_context(system_ctx: str, history: List[Dict[str,str]]) -> str:
    if not CLIENT:
        return ""
    try:
        resp = CLIENT.messages.create(
            model=ANTHROPIC_MODEL,
            system=f"{SYSTEM_HEAD}\nAnalyst Context: {system_ctx}",
            temperature=0.2,
            max_tokens=350,
            messages=[{"role": m["role"], "content": m["content"]} for m in history if m.get("content")],
        )
        return (resp.content[0].text or "").strip()
    except Exception as e:
        current_app.logger.exception("anthropic_error: %s", e)
        return ""

@conversation_bp.route("/start", methods=["POST"])
def start():
    p = request.get_json(silent=True) or {}
    desc = (p.get("description") or "").strip() or "Let's begin."
    sid = f"conv_{uuid.uuid4().hex[:12]}"

    history = [{"role":"user","content":desc}]
    slots = _extract_slots(desc)
    readiness = _readiness(slots)
    _, fallback_q = _next_question(slots)
    ctx = _analyst_context(slots)

    raw = _ask_with_context(ctx, history) or "Understood."
    reply = _ensure_two_sentences_one_question(raw, fallback_q)
    reply = _dedupe_against_last(history, reply)

    sess = {"session_id": sid, "history": [*history, {"role":"assistant","content":reply}], "slots": slots, "created_at": int(time.time())}
    _save_session(sid, sess)

    return jsonify({"session_id": sid, "message": reply, "readiness_score": readiness, "status": "gathering_info"})

@conversation_bp.route("/continue", methods=["POST"])
def cont():
    p = request.get_json(silent=True) or {}
    sid = p.get("session_id") or f"conv_{uuid.uuid4().hex[:12]}"
    user_msg = (p.get("message") or p.get("user_message") or "").strip()
    client_hist = p.get("conversation_history") or []

    sess = _load_session(sid)
    history = client_hist if client_hist else sess.get("history", [])
    if user_msg:
        if not history or history[-1].get("role")!="user" or _norm(history[-1].get("content",""))!=_norm(user_msg):
            history.append({"role":"user","content":user_msg})

    user_text = " ".join(m["content"] for m in history if m.get("role")=="user")
    slots = _extract_slots(user_text)
    readiness = _readiness(slots)
    _, fallback_q = _next_question(slots)
    ctx = _analyst_context(slots)

    raw = _ask_with_context(ctx, history) or "Got it."
    reply = _ensure_two_sentences_one_question(raw, fallback_q)
    reply = _dedupe_against_last(history, reply)

    new_hist = [*history, {"role":"assistant","content":reply}]
    _save_session(sid, {"session_id": sid, "history": new_hist, "slots": slots, "updated_at": int(time.time())})

    return jsonify({"session_id": sid, "message": reply, "readiness_score": readiness, "status": "gathering_info"})
