"""
Conversational AI Route for Sekki Market IQ (In-Memory Version)
Replaces rigid Q&A with intelligent, adaptive conversations
"""

import json
import time
import uuid
import os
from typing import Dict, List, Any, Optional
from flask import Blueprint, request, jsonify, current_app
import anthropic
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv(dotenv_path='/home/sekki/sekki-platform/backend/.env')

# Initialize Anthropic client
client = anthropic.Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))

conversational_ai_bp = Blueprint('conversational_ai', __name__)

# AI System Prompt for Business Analysis
SYSTEM_PROMPT = """You are an expert business analyst and financial advisor for Sekki, a platform that helps businesses make informed decisions. Your role is to conduct intelligent, conversational analysis of business projects and ideas.

OBJECTIVES:
1. Gather comprehensive information about the user's business project/idea
2. Understand financial goals, market context, and operational requirements
3. Identify risks, opportunities, and key success factors
4. Determine when you have sufficient information for analysis

CONVERSATION STYLE:
- Be conversational, professional, and insightful
- Ask intelligent follow-up questions based on responses
- Adapt your questioning based on the business model/industry
- Show expertise by asking about relevant business metrics
- Be concise but thorough

KEY INFORMATION TO GATHER:
- Business model and value proposition
- Target market and customer segments
- Revenue model and financial projections
- Competitive landscape
- Operational requirements and resources
- Timeline and milestones
- Budget and funding requirements
- Key risks and assumptions

ANALYSIS READINESS:
When you have gathered sufficient information across these areas, inform the user that you're ready to generate their Market IQ analysis. Tell them to type "finish" or "analyze" when they're ready to proceed.

IMPORTANT: 
- Never ask more than 2-3 questions at once
- Build on previous responses naturally
- Show understanding of their business context
- Be helpful and insightful, not just interrogative
"""

# In-memory session storage
sessions: Dict[str, Dict[str, Any]] = {}

class ConversationManager:
    def __init__(self):
        pass
        
    def create_session(self, description: str) -> Dict[str, Any]:
        """Create a new conversational analysis session"""
        session_id = f"conv_{uuid.uuid4().hex[:12]}"
        
        session = {
            "id": session_id,
            "description": description,
            "messages": [],
            "analysis_data": {},
            "status": "active",
            "created_at": int(time.time()),
            "readiness_score": 0,
            "key_areas_covered": []
        }
        
        sessions[session_id] = session

        # Start the conversation
        initial_response = self._get_ai_response(session, description)
        
        return {
            "session_id": session_id,
            "message": initial_response,
            "readiness_score": 0,
            "status": "gathering_info"
        }
    
    def continue_conversation(self, session_id: str, user_message: str) -> Dict[str, Any]:
        """Continue an existing conversation"""
        session = self._load_session(session_id)
        if not session:
            return {"error": "Session not found"}
        
        # Check if user wants to finish
        if user_message.lower().strip() in ['finish', 'analyze', 'done', 'ready']:
            return self._prepare_analysis(session)
        
        # Add user message to conversation
        session["messages"].append({
            "role": "user",
            "content": user_message,
            "timestamp": int(time.time())
        })
        
        # Get AI response
        ai_response = self._get_ai_response(session, user_message)
        
        # Update readiness score
        readiness_score = self._calculate_readiness(session)
        
        # Save session
        self._save_session(session)
        
        return {
            "message": ai_response,
            "readiness_score": readiness_score,
            "status": "ready_for_analysis" if readiness_score >= 80 else "gathering_info",
            "can_analyze": readiness_score >= 70
        }
    
    def _get_ai_response(self, session: Dict, user_input: str) -> str:
        """Generate AI response using Anthropic Claude"""
        try:
            # Build conversation history
            messages = []
            
            # Add conversation history
            for msg in session["messages"]:
                messages.append(msg)
            
            # Add current user input if it's not the initial description
            if user_input != session.get("description", ""):
                messages.append({"role": "user", "content": user_input})
            else:
                # Initial conversation starter
                messages.append({
                    "role": "user", 
                    "content": f"I want to analyze this business idea: {user_input}"
                })
            
            # Call Anthropic API
            response = client.messages.create(
                model="claude-3-opus-20240229",
                system=SYSTEM_PROMPT,
                messages=messages,
                max_tokens=1024,
            )
            
            ai_message = response.content[0].text
            
            # Add AI response to session
            session["messages"].append({
                "role": "assistant",
                "content": ai_message,
                "timestamp": int(time.time())
            })
            
            return ai_message
            
        except Exception as e:
            current_app.logger.error(f"Anthropic API error: {e}")
            return "I'm having trouble processing your request right now. Could you please try again?"
    
    def _calculate_readiness(self, session: Dict) -> int:
        """Calculate how ready we are for analysis based on conversation content"""
        conversation_text = " ".join([msg["content"] for msg in session["messages"]])
        
        # Key business areas to check for
        key_areas = {
            "business_model": ["business model", "revenue", "monetize", "make money", "pricing"],
            "market": ["market", "customers", "target", "audience", "competition"],
            "financials": ["budget", "cost", "investment", "funding", "profit", "revenue"],
            "operations": ["operations", "team", "resources", "timeline", "launch"],
            "risks": ["risk", "challenge", "concern", "problem", "obstacle"]
        }
        
        covered_areas = 0
        total_areas = len(key_areas)
        
        for area, keywords in key_areas.items():
            if any(keyword in conversation_text.lower() for keyword in keywords):
                covered_areas += 1
                if area not in session["key_areas_covered"]:
                    session["key_areas_covered"].append(area)
        
        # Calculate readiness score (0-100)
        base_score = (covered_areas / total_areas) * 70
        
        # Bonus points for conversation depth
        message_count = len(session["messages"])
        depth_bonus = min(message_count * 3, 30)
        
        readiness_score = min(int(base_score + depth_bonus), 100)
        session["readiness_score"] = readiness_score
        
        return readiness_score
    
    def _prepare_analysis(self, session: Dict) -> Dict[str, Any]:
        """Prepare the final analysis based on conversation"""
        # Extract key insights from conversation
        conversation_summary = self._extract_business_insights(session)
        
        # Generate Market IQ score and analysis
        analysis_result = self._generate_market_analysis(conversation_summary)
        
        session["status"] = "completed"
        session["analysis_result"] = analysis_result
        self._save_session(session)
        
        return {
            "status": "analysis_complete",
            "analysis": analysis_result,
            "session_id": session["id"]
        }
    
    def _extract_business_insights(self, session: Dict) -> Dict[str, Any]:
        """Extract structured business insights from conversation"""
        conversation_text = " ".join([
            msg["content"] for msg in session["messages"] 
            if msg["role"] == "user"
        ])
        
        # Use AI to extract structured data
        extraction_prompt = f"""
        Based on this business conversation, extract key business information:
        
        Conversation: {conversation_text}
        
        Extract and return JSON with:
        {{
            "business_description": "brief description",
            "target_market": "target customers",
            "revenue_model": "how they make money",
            "key_metrics": ["metric1", "metric2"],
            "main_risks": ["risk1", "risk2"],
            "competitive_advantages": ["advantage1", "advantage2"],
            "funding_requirements": "amount or description",
            "timeline": "launch timeline"
        }}
        """
        
        try:
            response = client.messages.create(
                model="claude-3-opus-20240229",
                system="You are a data extraction expert. Extract the requested information in JSON format.",
                messages=[{"role": "user", "content": extraction_prompt}],
                max_tokens=2048,
            )
            
            extracted_data = json.loads(response.content[0].text)
            return extracted_data
            
        except Exception as e:
            current_app.logger.error(f"Data extraction error: {e}")
            return {"business_description": session.get("description", "")}
    
    def _generate_market_analysis(self, insights: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive market analysis and scoring"""
        
        # This is where you'd implement your sophisticated analysis algorithms
        # For now, I'll create a structured response that matches your dashboard
        
        analysis = {
            "market_iq_score": self._calculate_market_score(insights),
            "financial_impact": self._calculate_financial_impact(insights),
            "component_analysis": self._analyze_components(insights),
            "key_insights": self._generate_insights(insights),
            "recommendations": self._generate_recommendations(insights),
            "risk_assessment": self._assess_risks(insights)
        }
        
        return analysis
    
    def _calculate_market_score(self, insights: Dict) -> Dict[str, Any]:
        """Calculate overall Market IQ score"""
        # Implement your scoring algorithm here
        # This is a simplified version
        base_score = 65
        
        # Adjust based on business model clarity
        if insights.get("revenue_model"):
            base_score += 10
        
        # Adjust based on market definition
        if insights.get("target_market"):
            base_score += 10
        
        # Adjust based on competitive advantages
        if insights.get("competitive_advantages"):
            base_score += 5
        
        score = min(base_score, 100)
        
        return {
            "score": score,
            "rating": "Excellent" if score >= 80 else "Good" if score >= 60 else "Fair"
        }
    
    def _calculate_financial_impact(self, insights: Dict) -> Dict[str, Any]:
        """Calculate financial impact metrics"""
        return {
            "ebitda_at_risk": "$50K",
            "potential_loss": "$100K", 
            "roi_opportunity": "$150K",
            "projected_ebitda": "$300K"
        }
    
    def _analyze_components(self, insights: Dict) -> List[Dict[str, Any]]:
        """Analyze business components"""
        return [
            {"name": "Financial Health", "score": 60, "icon": "dollar-sign"},
            {"name": "Operational Efficiency", "score": 70, "icon": "chart-line"},
            {"name": "Market Position", "score": 65, "icon": "bullseye"},
            {"name": "Execution Readiness", "score": 60, "icon": "users"}
        ]
    
    def _generate_insights(self, insights: Dict) -> List[str]:
        """Generate key business insights"""
        return [
            "Strong market opportunity identified",
            "Revenue model needs refinement",
            "Competitive positioning is clear",
            "Operational scaling plan required"
        ]
    
    def _generate_recommendations(self, insights: Dict) -> List[str]:
        """Generate actionable recommendations"""
        return [
            "Conduct detailed market research",
            "Develop MVP for customer validation", 
            "Create detailed financial projections",
            "Build strategic partnerships"
        ]
    
    def _assess_risks(self, insights: Dict) -> List[Dict[str, Any]]:
        """Assess business risks"""
        return [
            {"risk": "Market adoption uncertainty", "impact": "High", "probability": "Medium"},
            {"risk": "Competitive response", "impact": "Medium", "probability": "High"},
            {"risk": "Resource constraints", "impact": "Medium", "probability": "Medium"}
        ]
    
    def _load_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Load session from in-memory storage"""
        return sessions.get(session_id)
    
    def _save_session(self, session: Dict[str, Any]) -> None:
        """Save session to in-memory storage"""
        sessions[session['id']] = session

# Flask routes
@conversational_ai_bp.route("/conversation/start", methods=["POST"])
def start_conversation():
    """Start a new conversational analysis"""
    try:
        data = request.get_json() or {}
        description = data.get("description", "").strip()
        
        if not description:
            return jsonify({"error": "Description is required"}), 400
        
        # Initialize conversation manager
        manager = ConversationManager()
        
        result = manager.create_session(description)
        return jsonify(result), 200
        
    except Exception as e:
        current_app.logger.exception("conversation_start_failed")
        return jsonify({"error": "conversation_start_failed", "details": str(e)}), 500

@conversational_ai_bp.route("/conversation/continue", methods=["POST"])
def continue_conversation():
    """Continue an existing conversation"""
    try:
        data = request.get_json() or {}
        session_id = data.get("session_id", "").strip()
        message = data.get("message", "").strip()
        
        if not session_id or not message:
            return jsonify({"error": "Session ID and message are required"}), 400
        
        # Initialize conversation manager
        manager = ConversationManager()
        
        result = manager.continue_conversation(session_id, message)
        return jsonify(result), 200
        
    except Exception as e:
        current_app.logger.exception("conversation_continue_failed")
        return jsonify({"error": "conversation_continue_failed", "details": str(e)}), 500
