from flask import Blueprint, request, jsonify
import os, json, sqlite3, uuid
from datetime import datetime
from contextlib import contextmanager
from dotenv import load_dotenv

# ----- env & OpenAI client -----
load_dotenv()  # load .env at import time
from openai import OpenAI
def _client():
    return OpenAI()   # picks OPENAI_API_KEY from env/.env

MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")

market_iq_bp = Blueprint("market_iq", __name__, url_prefix="/api/market-iq")

# ----- SQLite persistence (shared across workers) -----
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
DB_PATH = os.getenv("MARKET_IQ_DB", os.path.join(BASE_DIR, "market_iq.db"))
os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)

def _dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

@contextmanager
def db():
    con = sqlite3.connect(DB_PATH, check_same_thread=False)
    con.row_factory = _dict_factory
    try:
        yield con
        con.commit()
    finally:
        con.close()

def init_db():
    with db() as con:
        con.execute("""
        CREATE TABLE IF NOT EXISTS sessions(
          id TEXT PRIMARY KEY,
          description TEXT NOT NULL,
          answers_json TEXT NOT NULL,
          last_field TEXT,
          last_question TEXT,
          total_q INTEGER NOT NULL,
          answered_q INTEGER NOT NULL,
          status TEXT NOT NULL,
          created_at TEXT NOT NULL
        )
        """)
init_db()

QUESTIONS = [
    ("primary_goal", "What's the primary business goal (e.g., revenue growth, margin, market share)?"),
    ("project_type", "What type of initiative is this (B2B SaaS, manufacturing expansion, product launch, etc.)?"),
    ("target_customer", "Who is the target customer/segment and typical deal size?"),
    ("market_geography", "Which geographies are you targeting first?"),
    ("market_size", "Estimated TAM/SAM/SOM or targetable customers in year 1?"),
    ("budget_total", "What's the total budget and its split (CapEx vs OpEx)?"),
    ("runway_months", "What runway or time horizon are we planning against (months)?"),
    ("timeline_target", "What is the target timeline to MVP and to broad launch?"),
    ("revenue_model", "How do you make money (pricing model / unit economics)?"),
    ("current_stage", "What stage are you in (idea, prototype, MVP, pilot, scaling)?"),
    ("team", "What team/capabilities are in place vs. gaps?"),
    ("competitors", "Who are the top 3 competitors and your differentiation?"),
    ("gtm_channels", "Which GTM channels do you plan (direct, partners, PLG, channel, etc.)?"),
    ("unit_economics", "Key unit economics (CAC, LTV, gross margin, payback)?"),
    ("key_risks", "Top 3 risks you foresee (execution, compliance, demand, supply, etc.)?"),
    ("constraints", "Any hard constraints (compliance, data, suppliers, dependencies)?"),
]
TOTAL_Q = len(QUESTIONS)

def _now():
    return datetime.utcnow().isoformat() + "Z"

def _load_session(con, sid):
    row = con.execute("SELECT * FROM sessions WHERE id=?", (sid,)).fetchone()
    if not row: return None
    row["answers"] = json.loads(row.get("answers_json") or "{}")
    return row

def _save_session(con, sess):
    data = dict(sess)
    data["answers_json"] = json.dumps(sess.get("answers", {}), ensure_ascii=False)
    cols = ("id","description","answers_json","last_field","last_question",
            "total_q","answered_q","status","created_at")
    vals = tuple(data.get(k) for k in cols)
    con.execute("""
      INSERT INTO sessions(id,description,answers_json,last_field,last_question,total_q,answered_q,status,created_at)
      VALUES(?,?,?,?,?,?,?,?,?)
      ON CONFLICT(id) DO UPDATE SET
        description=excluded.description,
        answers_json=excluded.answers_json,
        last_field=excluded.last_field,
        last_question=excluded.last_question,
        total_q=excluded.total_q,
        answered_q=excluded.answered_q,
        status=excluded.status
    """, vals)

def _score_with_llm(description, answers):
    sys = (
      "You are Market IQ. Score initiatives across finance, operations, market, execution. "
      "Output strict JSON:\n"
      "{"
      '"market_iq_score": int, "score_category": "Poor|Fair|Good|Strong|Excellent", '
      '"component_scores":{"financial_health":int,"operational_efficiency":int,"market_position":int,"execution_readiness":int},'
      '"financial_impact":{"ebitda_at_risk":str,"potential_loss":str,"roi_opportunity":str,"projected_ebitda":str,"time_to_market_impact":str},'
      '"key_insights":[str...],'
      '"top_risks":[{"risk":str,"impact":str,"mitigation":str}...],'
      '"recommendations":[{"action":str,"expected_impact":str,"effort":"Low|Medium|High","timeline":str}...]'
      "}"
    )
    user = json.dumps({"project_description": description, "answers": answers}, ensure_ascii=False)
    resp = _client().chat.completions.create(
        model=MODEL,
        temperature=0.2,
        response_format={"type":"json_object"},
        messages=[{"role":"system","content":sys},{"role":"user","content":user}]
    )
    return json.loads(resp.choices[0].message.content)

@market_iq_bp.route("/intake/start", methods=["POST"])
def intake_start():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400

        sid = "miq_" + uuid.uuid4().hex[:10]
        first_field, first_q = QUESTIONS[0]
        with db() as con:
            sess = {
                "id": sid, "description": description, "answers": {},
                "last_field": first_field, "last_question": first_q,
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now()
            }
            _save_session(con, sess)
        return jsonify({"analysis_id": sid, "field": first_field, "question": first_q,
                        "answered": 0, "total_questions": TOTAL_Q})
    except Exception as e:
        return jsonify({"error":"intake_start_failed","details":str(e)}), 500

@market_iq_bp.route("/intake/answer", methods=["POST"])
def intake_answer():
    try:
        data = request.get_json(force=True) or {}
        sid = data.get("analysis_id")
        field = data.get("field")
        answer = data.get("answer")
        if not sid or field is None or answer is None:
            return jsonify({"error":"missing_params"}), 400

        with db() as con:
            sess = _load_session(con, sid)
            if not sess: return jsonify({"error":"unknown_analysis_id"}), 404

            if field not in sess["answers"]:
                sess["answered_q"] += 1
            sess["answers"][field] = answer

            if sess["answered_q"] >= sess["total_q"]:
                try:
                    analysis = _score_with_llm(sess["description"], sess["answers"])
                except Exception as e:
                    return jsonify({"error":"llm_unavailable","details":str(e)}), 503
                sess["status"] = "complete"
                _save_session(con, sess)
                analysis["analysis_id"] = sid
                analysis["timestamp"] = _now()
                analysis["answers"] = sess["answers"]
                analysis["description"] = sess["description"]
                return jsonify({"complete": True, "analysis_result": analysis})

            remaining = [f for f,_ in QUESTIONS if f not in sess["answers"]]
            next_field = remaining[0]
            next_q = dict(QUESTIONS)[next_field]
            sess["last_field"] = next_field
            sess["last_question"] = next_q
            _save_session(con, sess)

            return jsonify({
                "complete": False,
                "next_field": next_field,
                "next_question": next_q,
                "answered": sess["answered_q"],
                "total_questions": sess["total_q"]
            })
    except Exception as e:
        return jsonify({"error":"intake_answer_failed","details":str(e)}), 500

@market_iq_bp.route("/scenario", methods=["POST"])
def scenario():
    try:
        data = request.get_json(force=True) or {}
        base = data.get("analysis_result") or {}
        changes = data.get("changes") or {}
        description = base.get("description") or "Scenario"
        answers = base.get("answers") or {}
        answers.update(changes)
        try:
            analysis = _score_with_llm(description, answers)
        except Exception as e:
            return jsonify({"error":"llm_unavailable","details":str(e)}), 503
        analysis["scenario_from"] = base.get("analysis_id")
        analysis["analysis_id"] = "miq_" + uuid.uuid4().hex[:10]
        analysis["timestamp"] = _now()
        analysis["answers"] = answers
        analysis["description"] = description
        return jsonify(analysis)
    except Exception as e:
        return jsonify({"error":"scenario_failed","details":str(e)}), 500

@market_iq_bp.route("/analyze", methods=["POST"])
def analyze_shim():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or data.get("project_description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400
        sid = "miq_" + uuid.uuid4().hex[:10]
        first_field, first_q = QUESTIONS[0]
        with db() as con:
            _save_session(con, {
                "id": sid, "description": description, "answers": {},
                "last_field": first_field, "last_question": first_q,
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now()
            })
        return jsonify({"analysis_id": sid, "field": first_field, "question": first_q,
                        "answered": 0, "total_questions": TOTAL_Q})
    except Exception as e:
        return jsonify({"error":"analyze_failed","details":str(e)}), 500
