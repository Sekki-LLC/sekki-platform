from flask import Blueprint, request, jsonify
import os, json, sqlite3, uuid
from datetime import datetime
from contextlib import contextmanager
from dotenv import load_dotenv

# ----- env & OpenAI client -----
load_dotenv()  # load .env at import time
from openai import OpenAI
def _client():
    return OpenAI()   # picks OPENAI_API_KEY from env/.env

MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")

# Behavior toggles (no code changes needed to tune):
DYNAMIC_INTAKE = os.getenv("MARKET_IQ_DYNAMIC", "1") not in ("0","false","False")
EARLY_STOP     = os.getenv("MARKET_IQ_EARLY_STOP", "1") not in ("0","false","False")
MIN_FIELDS     = int(os.getenv("MARKET_IQ_MIN_FIELDS", "10"))  # score once >= this and coverage is "sufficient"

market_iq_bp = Blueprint("market_iq", __name__, url_prefix="/api/market-iq")

# ----- SQLite persistence (shared across workers) -----
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
DB_PATH = os.getenv("MARKET_IQ_DB", os.path.join(BASE_DIR, "market_iq.db"))
os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)

def _dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

@contextmanager
def db():
    con = sqlite3.connect(DB_PATH, check_same_thread=False)
    con.row_factory = _dict_factory
    try:
        yield con
        con.commit()
    finally:
        con.close()

def init_db():
    with db() as con:
        con.execute("""
        CREATE TABLE IF NOT EXISTS sessions(
          id TEXT PRIMARY KEY,
          description TEXT NOT NULL,
          answers_json TEXT NOT NULL,
          last_field TEXT,
          last_question TEXT,
          total_q INTEGER NOT NULL,
          answered_q INTEGER NOT NULL,
          status TEXT NOT NULL,
          created_at TEXT NOT NULL
        )
        """)
init_db()

QUESTIONS = [
    ("primary_goal", "What's the primary business goal (e.g., revenue growth, margin, market share)?"),
    ("project_type", "What type of initiative is this (B2B SaaS, manufacturing expansion, product launch, etc.)?"),
    ("target_customer", "Who is the target customer/segment and typical deal size?"),
    ("market_geography", "Which geographies are you targeting first?"),
    ("market_size", "Estimated TAM/SAM/SOM or targetable customers in year 1?"),
    ("budget_total", "What's the total budget and its split (CapEx vs OpEx)?"),
    ("runway_months", "What runway or time horizon are we planning against (months)?"),
    ("timeline_target", "What is the target timeline to MVP and to broad launch?"),
    ("revenue_model", "How do you make money (pricing model / unit economics)?"),
    ("current_stage", "What stage are you in (idea, prototype, MVP, pilot, scaling)?"),
    ("team", "What team/capabilities are in place vs. gaps?"),
    ("competitors", "Who are the top 3 competitors and your differentiation?"),
    ("gtm_channels", "Which GTM channels do you plan (direct, partners, PLG, channel, etc.)?"),
    ("unit_economics", "Key unit economics (CAC, LTV, gross margin, payback)?"),
    ("key_risks", "Top 3 risks you foresee (execution, compliance, demand, supply, etc.)?"),
    ("constraints", "Any hard constraints (compliance, data, suppliers, dependencies)?"),
]
TOTAL_Q = len(QUESTIONS)
QUESTION_TEXT = dict(QUESTIONS)
FIELDS = [f for f,_ in QUESTIONS]

def _now():
    return datetime.utcnow().isoformat() + "Z"

def _load_session(con, sid):
    row = con.execute("SELECT * FROM sessions WHERE id=?", (sid,)).fetchone()
    if not row: return None
    row["answers"] = json.loads(row.get("answers_json") or "{}")
    return row

def _save_session(con, sess):
    data = dict(sess)
    data["answers_json"] = json.dumps(sess.get("answers", {}), ensure_ascii=False)
    cols = ("id","description","answers_json","last_field","last_question",
            "total_q","answered_q","status","created_at")
    vals = tuple(data.get(k) for k in cols)
    con.execute("""
      INSERT INTO sessions(id,description,answers_json,last_field,last_question,total_q,answered_q,status,created_at)
      VALUES(?,?,?,?,?,?,?,?,?)
      ON CONFLICT(id) DO UPDATE SET
        description=excluded.description,
        answers_json=excluded.answers_json,
        last_field=excluded.last_field,
        last_question=excluded.last_question,
        total_q=excluded.total_q,
        answered_q=excluded.answered_q,
        status=excluded.status
    """, vals)

def _score_with_llm(description, answers):
    sys = (
      "You are Market IQ. Score initiatives across finance, operations, market, execution. "
      "Output strict JSON:\n"
      "{"
      '"market_iq_score": int, "score_category": "Poor|Fair|Good|Strong|Excellent", '
      '"component_scores":{"financial_health":int,"operational_efficiency":int,"market_position":int,"execution_readiness":int},'
      '"financial_impact":{"ebitda_at_risk":str,"potential_loss":str,"roi_opportunity":str,"projected_ebitda":str,"time_to_market_impact":str},'
      '"key_insights":[str...],'
      '"top_risks":[{"risk":str,"impact":str,"mitigation":str}...],'
      '"recommendations":[{"action":str,"expected_impact":str,"effort":"Low|Medium|High","timeline":str}...]'
      "}"
    )
    user = json.dumps({"project_description": description, "answers": answers}, ensure_ascii=False)
    resp = _client().chat.completions.create(
        model=MODEL,
        temperature=0.2,
        response_format={"type":"json_object"},
        messages=[{"role":"system","content":sys},{"role":"user","content":user}]
    )
    return json.loads(resp.choices[0].message.content)

# ===== Helpers for adaptive flow =====
def _extract_fields(description, current, user_text):
    """
    Use LLM to pull ANY definable fields from a single user message.
    Returns: dict(extracted={field:value...}, clarifications=[{field,question}...])
    """
    if not DYNAMIC_INTAKE:
        return {"extracted":{}, "clarifications":[]}
    try:
        sys = (
          "Extract structured answers for a Market IQ intake.\n"
          "Fields: " + ", ".join(FIELDS) + "\n"
          "Rules:\n"
          " - Only extract a field if the value is explicit and actionable.\n"
          " - If units/precision are missing (e.g., 'budget' without $ or split), propose a concise clarifying question.\n"
          "Output strict JSON: {\"extracted\": {<field>: <value>...}, \"clarifications\": [{\"field\":str,\"question\":str}...]}"
        )
        user = json.dumps({
            "project_description": description,
            "already_captured": current,
            "user_message": user_text
        }, ensure_ascii=False)
        resp = _client().chat.completions.create(
            model=MODEL, temperature=0.2,
            response_format={"type":"json_object"},
            messages=[{"role":"system","content":sys},{"role":"user","content":user}],
        )
        data = json.loads(resp.choices[0].message.content)
        extracted = {k:v for k,v in (data.get("extracted") or {}).items() if k in FIELDS}
        clar = [c for c in (data.get("clarifications") or []) if c.get("field") in FIELDS and c.get("question")]
        return {"extracted": extracted, "clarifications": clar}
    except Exception:
        return {"extracted":{}, "clarifications":[]}

def _coverage_ok(description, answers):
    """
    Ask LLM if we have 'enough' to score accurately (semantic coverage),
    used only when EARLY_STOP is enabled and answered >= MIN_FIELDS.
    """
    if not EARLY_STOP:
        return False
    try:
        sys = (
          "Decide if the provided answers cover enough for a reliable Market IQ score.\n"
          "Fields expected: " + ", ".join(FIELDS) + "\n"
          "Output strict JSON: {\"ready\": bool, \"missing\": [str...]} "
          "where 'missing' are the most vital gaps (max 3)."
        )
        user = json.dumps({"project_description": description, "answers": answers}, ensure_ascii=False)
        resp = _client().chat.completions.create(
            model=MODEL, temperature=0.0,
            response_format={"type":"json_object"},
            messages=[{"role":"system","content":sys},{"role":"user","content":user}],
        )
        data = json.loads(resp.choices[0].message.content)
        return bool(data.get("ready"))
    except Exception:
        return False

def _choose_next_question(description, answers, last_field=None, last_answer=None):
    """
    Returns (field, question_text). Uses LLM when DYNAMIC_INTAKE=1, else static order.
    Clarifications do NOT advance answered_q unless a new field is provided.
    Questions are rephrased in the user's language; avoid robotic tone.
    """
    remaining = [f for f in FIELDS if f not in answers]
    if not remaining:
        return (None, None)

    if not DYNAMIC_INTAKE:
        f = remaining[0]
        return (f, QUESTION_TEXT.get(f, f.replace("_", " ").title()+"?"))

    try:
        sys = (
          "You are a senior product interviewer.\n"
          "Goal: Collect the missing info for a Market IQ score with minimal, natural back-and-forth.\n"
          "Required fields with their base prompts:\n"
          + "\n".join(f"- {f}: {QUESTION_TEXT.get(f)}" for f in FIELDS) +
          "\n\nTone/Behavior:\n"
          " - Ask ONE concise question now.\n"
          " - If the last answer is vague for the last field, ask a short clarifying follow-up about that field.\n"
          " - Otherwise pick the most impactful missing field.\n"
          " - Rephrase in the user's terms; vary phrasing (don't sound scripted).\n"
          "Output strict JSON: {\"field\": str, \"question\": str, \"clarifying\": bool}"
        )
        user = json.dumps({
            "project_description": description,
            "answered": answers,
            "remaining_fields": remaining,
            "last_field": last_field,
            "last_answer": last_answer,
        }, ensure_ascii=False)

        resp = _client().chat.completions.create(
            model=MODEL, temperature=0.4,
            response_format={"type":"json_object"},
            messages=[{"role":"system","content":sys},{"role":"user","content":user}],
        )
        data = json.loads(resp.choices[0].message.content)
        field = data.get("field") or (remaining[0] if remaining else None)
        if field not in QUESTION_TEXT:
            field = remaining[0]
        question = (data.get("question") or QUESTION_TEXT.get(field) or "Could you share more detail?")
        return (field, question.strip())
    except Exception:
        f = remaining[0]
        return (f, QUESTION_TEXT.get(f, f.replace("_", " ").title()+"?"))

@market_iq_bp.route("/intake/start", methods=["POST"])
def intake_start():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400

        sid = "miq_" + uuid.uuid4().hex[:10]
        first_field, first_q = _choose_next_question(description, {}, None, None)
        with db() as con:
            sess = {
                "id": sid, "description": description, "answers": {},
                "last_field": first_field, "last_question": first_q,
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now()
            }
            _save_session(con, sess)
        return jsonify({"analysis_id": sid, "field": first_field, "question": first_q,
                        "answered": 0, "total_questions": TOTAL_Q})
    except Exception as e:
        return jsonify({"error":"intake_start_failed","details":str(e)}), 500

@market_iq_bp.route("/intake/answer", methods=["POST"])
def intake_answer():
    try:
        data = request.get_json(force=True) or {}
        sid = data.get("analysis_id")
        field = data.get("field") or data.get("next_field")  # may be omitted by client
        answer = data.get("answer")
        if not sid or answer is None:
            return jsonify({"error":"missing_params"}), 400

        with db() as con:
            sess = _load_session(con, sid)
            if not sess: return jsonify({"error":"unknown_analysis_id"}), 404

            # If caller omitted field, fall back to last_field
            if field is None:
                field = sess.get("last_field")

            # 1) Apply extraction to capture multiple fields from this one answer
            extract = _extract_fields(sess["description"], sess["answers"], str(answer))
            newly_added = 0
            for f, val in (extract.get("extracted") or {}).items():
                if f not in sess["answers"]:
                    sess["answered_q"] += 1
                    newly_added += 1
                sess["answers"][f] = val

            # 2) If client explicitly answered a named field, record/overwrite it
            if field:
                if field not in sess["answers"]:
                    sess["answered_q"] += 1
                sess["answers"][field] = answer

            # 3) Early-stop check (only if enough fields and model says coverage ok)
            if EARLY_STOP and sess["answered_q"] >= MIN_FIELDS and _coverage_ok(sess["description"], sess["answers"]):
                try:
                    analysis = _score_with_llm(sess["description"], sess["answers"])
                except Exception as e:
                    return jsonify({"error":"llm_unavailable","details":str(e)}), 503
                sess["status"] = "complete"
                _save_session(con, sess)
                analysis["analysis_id"] = sid
                analysis["timestamp"] = _now()
                analysis["answers"] = sess["answers"]
                analysis["description"] = sess["description"]
                return jsonify({"complete": True, "analysis_result": analysis})

            # 4) Not complete: prefer a clarifying follow-up generated by extraction
            clar = (extract.get("clarifications") or [])
            next_field, next_q = None, None
            if clar:
                next_field = clar[0].get("field")
                next_q = clar[0].get("question")

            # 5) Or choose the next best question adaptively
            if not next_q:
                next_field, next_q = _choose_next_question(
                    sess["description"], sess["answers"], field, str(answer)
                )

            sess["last_field"] = next_field
            sess["last_question"] = next_q
            _save_session(con, sess)

            return jsonify({
                "complete": False,
                "next_field": next_field,
                "next_question": next_q,
                "answered": sess["answered_q"],
                "total_questions": sess["total_q"]
            })
    except Exception as e:
        return jsonify({"error":"intake_answer_failed","details":str(e)}), 500

@market_iq_bp.route("/scenario", methods=["POST"])
def scenario():
    try:
        data = request.get_json(force=True) or {}
        base = data.get("analysis_result") or {}
        changes = data.get("changes") or {}
        description = base.get("description") or "Scenario"
        answers = base.get("answers") or {}
        answers.update(changes)
        try:
            analysis = _score_with_llm(description, answers)
        except Exception as e:
            return jsonify({"error":"llm_unavailable","details":str(e)}), 503
        analysis["scenario_from"] = base.get("analysis_id")
        analysis["analysis_id"] = "miq_" + uuid.uuid4().hex[:10]
        analysis["timestamp"] = _now()
        analysis["answers"] = answers
        analysis["description"] = description
        return jsonify(analysis)
    except Exception as e:
        return jsonify({"error":"scenario_failed","details":str(e)}), 500

@market_iq_bp.route("/analyze", methods=["POST"])
def analyze_shim():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or data.get("project_description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400
        sid = "miq_" + uuid.uuid4().hex[:10]
        first_field, first_q = _choose_next_question(description, {}, None, None)
        with db() as con:
            _save_session(con, {
                "id": sid, "description": description, "answers": {},
                "last_field": first_field, "last_question": first_q,
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now()
            })
        return jsonify({"analysis_id": sid, "field": first_field, "question": first_q,
                        "answered": 0, "total_questions": TOTAL_Q})
    except Exception as e:
        return jsonify({"error":"analyze_failed","details":str(e)}), 500
