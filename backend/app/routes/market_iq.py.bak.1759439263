from flask import Blueprint, request, jsonify
import os, json, sqlite3, uuid, re, time
from datetime import datetime
from contextlib import contextmanager
from dotenv import load_dotenv

load_dotenv()
from openai import OpenAI
def _client():
    return OpenAI()   # reads OPENAI_API_KEY

MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
TONE = os.getenv("MARKET_IQ_TONE", "warm, executive, concise, business-specific")
VARIETY = float(os.getenv("MARKET_IQ_VARIETY", "0.5"))
MAX_FOLLOWUPS_PER_FIELD = int(os.getenv("MARKET_IQ_MAX_FU", "2"))

market_iq_bp = Blueprint("market_iq", __name__, url_prefix="/api/market-iq")

BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
DB_PATH = os.getenv("MARKET_IQ_DB", os.path.join(BASE_DIR, "market_iq.db"))
os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)

def _dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

@contextmanager
def db():
    con = sqlite3.connect(DB_PATH, check_same_thread=False)
    con.row_factory = _dict_factory
    try:
        yield con
        con.commit()
    finally:
        con.close()

def init_db():
    with db() as con:
        con.execute("""
        CREATE TABLE IF NOT EXISTS sessions(
          id TEXT PRIMARY KEY,
          description TEXT NOT NULL,
          answers_json TEXT NOT NULL,
          last_field TEXT,
          last_question TEXT,
          total_q INTEGER NOT NULL,
          answered_q INTEGER NOT NULL,
          status TEXT NOT NULL,
          created_at TEXT NOT NULL,
          fu_counts_json TEXT
        )
        """)
        # --- self-healing migration: ensure fu_counts_json exists
        cols = [r["name"] for r in con.execute("PRAGMA table_info(sessions);").fetchall()]
        if "fu_counts_json" not in cols:
            con.execute("ALTER TABLE sessions ADD COLUMN fu_counts_json TEXT;")

init_db()

QUESTIONS = [
    ("primary_goal", "What’s the primary business goal (e.g., revenue growth, margin, market share)?"),
    ("project_type", "What type of initiative is this (B2B SaaS, manufacturing expansion, product launch, etc.)?"),
    ("target_customer", "Who is the target customer/segment and typical deal size?"),
    ("market_geography", "Which geographies are you targeting first?"),
    ("market_size", "Estimated TAM/SAM/SOM or targetable customers in year 1?"),
    ("budget_total", "What’s the total budget and its split (CapEx vs OpEx)?"),
    ("runway_months", "What runway or time horizon are we planning against (months)?"),
    ("timeline_target", "Target timeline to MVP and to broad launch?"),
    ("revenue_model", "How do you make money (pricing model / unit economics)?"),
    ("current_stage", "What stage are you in (idea, prototype, MVP, pilot, scaling)?"),
    ("team", "What team/capabilities are in place vs gaps?"),
    ("competitors", "Top 3 competitors and your differentiation?"),
    ("gtm_channels", "Which GTM channels do you plan (direct, partners, PLG, channel, etc.)?"),
    ("unit_economics", "Key unit economics (CAC, LTV, gross margin, payback)?"),
    ("key_risks", "Top 3 risks you foresee (execution, compliance, demand, supply, etc.)?"),
    ("constraints", "Any hard constraints (compliance, data, suppliers, dependencies)?"),
]
TOTAL_Q = len(QUESTIONS)
QUESTION_MAP = dict(QUESTIONS)

def _now():
    return datetime.utcnow().isoformat() + "Z"

def _load_session(con, sid):
    row = con.execute("SELECT * FROM sessions WHERE id=?", (sid,)).fetchone()
    if not row: return None
    row["answers"] = json.loads(row.get("answers_json") or "{}")
    row["fu_counts"] = json.loads(row.get("fu_counts_json") or "{}")
    return row

def _save_session(con, sess):
    data = dict(sess)
    data["answers_json"] = json.dumps(sess.get("answers", {}), ensure_ascii=False)
    data["fu_counts_json"] = json.dumps(sess.get("fu_counts", {}), ensure_ascii=False)
    cols = ("id","description","answers_json","last_field","last_question",
            "total_q","answered_q","status","created_at","fu_counts_json")
    vals = tuple(data.get(k) for k in cols)
    con.execute(f"""
      INSERT INTO sessions({','.join(cols)})
      VALUES({','.join(['?']*len(cols))})
      ON CONFLICT(id) DO UPDATE SET
        description=excluded.description,
        answers_json=excluded.answers_json,
        last_field=excluded.last_field,
        last_question=excluded.last_question,
        total_q=excluded.total_q,
        answered_q=excluded.answered_q,
        status=excluded.status,
        fu_counts_json=excluded.fu_counts_json
    """, vals)

from typing import Optional, Dict, Any
def _chat_json(system: str, user_payload: Dict[str, Any], temperature=0.2, max_retries=3):
    for i in range(max_retries):
        try:
            resp = _client().chat.completions.create(
                model=MODEL,
                temperature=temperature,
                response_format={"type":"json_object"},
                messages=[
                    {"role":"system","content":system},
                    {"role":"user","content":json.dumps(user_payload, ensure_ascii=False)}
                ]
            )
            return json.loads(resp.choices[0].message.content)
        except Exception:
            if i == max_retries - 1:
                raise
            time.sleep(0.6 * (i+1))
    return {}

def _maybe_vague(text:str)->bool:
    if not text: return True
    t = text.strip().lower()
    if len(t) < 8: return True
    return bool(re.search(r"\b(not sure|don'?t know|idk|tbd|unsure)\b", t))

def _phrase_question(description, answers, field, base_question, last_answer=None):
    sys = (
      "You are a helpful business analyst interviewing an executive. "
      f"Tone: {TONE}. Ask exactly ONE crisp question. "
      "If the last answer is vague, include a short clarifying follow-up. "
      "Do not repeat wording. No pleasantries or lists."
    )
    payload = {
        "project_description": description,
        "answers_so_far": answers,
        "next_field": field,
        "base_question": base_question,
        "last_answer": last_answer,
    }
    try:
        j = _chat_json(sys, payload, temperature=max(0.2, min(VARIETY, 0.9)))
        q = (j.get("question") or base_question).strip()
        ask_fu = bool(j.get("ask_followup"))
        fu = (j.get("followup") or "").strip() or None
    except Exception:
        q, ask_fu, fu = base_question, False, None

    if last_answer is not None and _maybe_vague(last_answer):
        ask_fu = True if ask_fu is None else ask_fu
        if not fu:
            fu = "Could you narrow it down—e.g., North America, EMEA, APAC, or another region?"
    if not q: q = base_question
    return {"question": q, "ask_followup": ask_fu, "followup": fu}

def _score_with_llm(description, answers):
    sys = (
      "You are Market IQ. Score initiatives across finance, operations, market, execution. "
      "Return strict JSON with keys: market_iq_score, score_category, component_scores, "
      "financial_impact, key_insights, top_risks, recommendations."
    )
    user = {"project_description": description, "answers": answers}
    resp = _client().chat.completions.create(
        model=MODEL,
        temperature=0.2,
        response_format={"type":"json_object"},
        messages=[{"role":"system","content":sys},{"role":"user","content":json.dumps(user, ensure_ascii=False)}]
    )
    return json.loads(resp.choices[0].message.content)

@market_iq_bp.route("/intake/start", methods=["POST"])
def intake_start():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400

        sid = "miq_" + uuid.uuid4().hex[:10]
        first_field, base_q = QUESTIONS[0]

        with db() as con:
            phr = _phrase_question(description, {}, first_field, base_q, last_answer=None)
            sess = {
                "id": sid, "description": description, "answers": {},
                "last_field": first_field, "last_question": phr["question"],
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now(), "fu_counts": {}
            }
            _save_session(con, sess)

        return jsonify({
            "analysis_id": sid,
            "field": first_field,
            "question": phr["question"],
            "answered": 0,
            "total_questions": TOTAL_Q
        })
    except Exception as e:
        return jsonify({"error":"intake_start_failed","details":str(e)}), 500

@market_iq_bp.route("/intake/answer", methods=["POST"])
def intake_answer():
    try:
        data = request.get_json(force=True) or {}
        sid    = data.get("analysis_id")
        field  = data.get("field")
        answer = data.get("answer")
        if not sid or field is None or answer is None:
            return jsonify({"error":"missing_params"}), 400

        with db() as con:
            sess = _load_session(con, sid)
            if not sess: return jsonify({"error":"unknown_analysis_id"}), 404

            if field not in sess["answers"]:
                sess["answered_q"] += 1
                sess.setdefault("fu_counts", {})[field] = 0
            sess["answers"][field] = answer

            fu_count = sess.get("fu_counts", {}).get(field, 0)
            phr_cur = _phrase_question(sess["description"], sess["answers"], field, QUESTION_MAP[field], last_answer=answer)
            if phr_cur["ask_followup"] and fu_count < MAX_FOLLOWUPS_PER_FIELD:
                sess["fu_counts"][field] = fu_count + 1
                sess["last_field"] = field
                sess["last_question"] = phr_cur["followup"] or phr_cur["question"]
                _save_session(con, sess)
                return jsonify({
                    "complete": False,
                    "next_field": field,
                    "next_question": sess["last_question"],
                    "answered": sess["answered_q"],
                    "total_questions": sess["total_q"]
                })

            if sess["answered_q"] >= sess["total_q"]:
                try:
                    analysis = _score_with_llm(sess["description"], sess["answers"])
                except Exception as e:
                    return jsonify({"error":"llm_unavailable","details":str(e)}), 503
                sess["status"] = "complete"
                _save_session(con, sess)
                analysis["analysis_id"] = sid
                analysis["timestamp"] = _now()
                analysis["answers"] = sess["answers"]
                analysis["description"] = sess["description"]
                return jsonify({"complete": True, "analysis_result": analysis})

            remaining = [f for f,_ in QUESTIONS if f not in sess["answers"]]
            next_field = remaining[0]
            base_q = QUESTION_MAP[next_field]
            phr_next = _phrase_question(sess["description"], sess["answers"], next_field, base_q, last_answer=answer)

            sess["last_field"] = next_field
            sess["last_question"] = phr_next["question"]
            _save_session(con, sess)

            return jsonify({
                "complete": False,
                "next_field": next_field,
                "next_question": sess["last_question"],
                "answered": sess["answered_q"],
                "total_questions": sess["total_q"]
            })
    except Exception as e:
        return jsonify({"error":"intake_answer_failed","details":str(e)}), 500

@market_iq_bp.route("/scenario", methods=["POST"])
def scenario():
    try:
        data = request.get_json(force=True) or {}
        base = data.get("analysis_result") or {}
        changes = data.get("changes") or {}
        description = base.get("description") or "Scenario"
        answers = (base.get("answers") or {}).copy()
        answers.update(changes)
        try:
            analysis = _score_with_llm(description, answers)
        except Exception as e:
            return jsonify({"error":"llm_unavailable","details":str(e)}), 503
        analysis["scenario_from"] = base.get("analysis_id")
        analysis["analysis_id"] = "miq_" + uuid.uuid4().hex[:10]
        analysis["timestamp"] = _now()
        analysis["answers"] = answers
        analysis["description"] = description
        return jsonify(analysis)
    except Exception as e:
        return jsonify({"error":"scenario_failed","details":str(e)}), 500

@market_iq_bp.route("/analyze", methods=["POST"])
def analyze_shim():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or data.get("project_description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400
        sid = "miq_" + uuid.uuid4().hex[:10]
        first_field, base_q = QUESTIONS[0]
        with db() as con:
            phr = _phrase_question(description, {}, first_field, base_q, last_answer=None)
            _save_session(con, {
                "id": sid, "description": description, "answers": {},
                "last_field": first_field, "last_question": phr["question"],
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now(), "fu_counts": {}
            })
        return jsonify({
            "analysis_id": sid,
            "field": first_field,
            "question": phr["question"],
            "answered": 0,
            "total_questions": TOTAL_Q
        })
    except Exception as e:
        return jsonify({"error":"analyze_failed","details":str(e)}), 500
