from flask import Blueprint, request, jsonify
import os, time, uuid, json

market_iq_bp = Blueprint('market_iq', __name__, url_prefix='/api/market-iq')

# --- simple in-memory state (OK for single process) ---
_SESS = {}  # analysis_id -> {"description": str, "answers": [str], "questions": [str], "created": ts}

# --- LLM client wrapper (OpenAI v1) ---
_OPENAI_CLIENT = None
def _get_openai():
    global _OPENAI_CLIENT
    if _OPENAI_CLIENT is not None:
        return _OPENAI_CLIENT
    try:
        from openai import OpenAI
        _OPENAI_CLIENT = OpenAI()
        return _OPENAI_CLIENT
    except Exception:
        return None

def _call_llm_json(system, user, model=None, temperature=0.2):
    client = _get_openai()
    if not client:
        return None  # no LLM available
    mdl = model or os.getenv("OPENAI_MODEL", "gpt-4o-mini")
    resp = client.chat.completions.create(
        model=mdl,
        response_format={"type": "json_object"},
        temperature=temperature,
        messages=[
            {"role": "system", "content": system},
            {"role": "user", "content": user},
        ],
    )
    content = resp.choices[0].message.content
    try:
        return json.loads(content)
    except Exception:
        return None

def _score_category(score):
    if score >= 85: return "Excellent"
    if score >= 70: return "Good Performance"
    if score >= 55: return "Moderate"
    return "Needs Attention"

def _finalize_payload(analysis_id, js):
    comp = js.get("component_scores", {})
    fin = js.get("financial_impact", {})

    total = js.get("market_iq_score")
    if total is None:
        parts = [comp.get(k) for k in ("financial_health","operational_efficiency","market_position","execution_readiness") if isinstance(comp.get(k), (int,float))]
        total = round(sum(parts)/len(parts)) if parts else 65

    payload = {
        "market_iq_score": int(total),
        "score_category": _score_category(int(total)),
        "component_scores": {
            "financial_health": int(comp.get("financial_health", 70)),
            "operational_efficiency": int(comp.get("operational_efficiency", 65)),
            "market_position": int(comp.get("market_position", 72)),
            "execution_readiness": int(comp.get("execution_readiness", 68)),
        },
        "financial_impact": {
            "ebitda_at_risk": fin.get("ebitda_at_risk", "15%"),
            "potential_loss": fin.get("potential_loss", "$300K"),
            "roi_opportunity": fin.get("roi_opportunity", "8%"),
            "projected_ebitda": fin.get("projected_ebitda", "$2.1M"),
            "time_to_market_impact": fin.get("time_to_market_impact", "3 months delay = $450K revenue loss"),
        },
        "key_insights": js.get("key_insights", [])[:6],
        "top_risks": js.get("top_risks", [])[:4],
        "recommendations": js.get("recommendations", [])[:5],
        "analysis_id": analysis_id,
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    }
    return payload

SYSTEM_ANALYST = (
    "You are MarketIQ, a pragmatic B2B operator and financial analyst. "
    "You must either: (A) ask one targeted follow-up question if critical inputs are missing, "
    "or (B) produce a complete, defensible score and summary. "
    "Respond ONLY as JSON; no prose."
)

USER_TEMPLATE = """Context so far:
- Initial description: {description}
- Answers provided (ordered): {answers}

Goal:
1) If you still lack critical inputs (budget, timeline, target customer/segment, GTM approach, competitors, success metrics), return:
{
  "status": "needs_followup",
  "question": "ONE specific question that will unblock you next",
  "missing_fields": ["list", "of", "still-missing", "items"]
}

2) If you can produce a defensible result now, return:
{
  "status": "complete",
  "market_iq_score": 0-100 integer,
  "component_scores": {
    "financial_health": 0-100,
    "operational_efficiency": 0-100,
    "market_position": 0-100,
    "execution_readiness": 0-100
  },
  "financial_impact": {
    "ebitda_at_risk": "percent or rough $",
    "potential_loss": "$X",
    "roi_opportunity": "percent or $",
    "projected_ebitda": "$X",
    "time_to_market_impact": "e.g., '3 months delay = $450K revenue loss'"
  },
  "key_insights": ["3-6 concise bullets"],
  "top_risks": [{"risk":"...", "impact":"...", "mitigation":"..."}, ...],
  "recommendations": [{"action":"...", "expected_impact":"...", "effort":"Low|Medium|High", "timeline":"..."}]
}

Rules:
- Ask ONE follow-up at a time if needed.
- Do NOT repeat the same question previously asked.
- Be concrete and businesslike.
"""

@market_iq_bp.route('/analyze', methods=['POST'])
def analyze():
    data = request.get_json(force=True) or {}
    description = data.get("description")
    analysis_id = data.get("analysis_id")
    answer = data.get("answer")

    # new analysis
    if description and not analysis_id:
        analysis_id = "miq_" + uuid.uuid4().hex[:8]
        _SESS[analysis_id] = {
            "description": description.strip(),
            "answers": [],
            "questions": [],
            "created": time.time()
        }

    # follow-up answer arrives
    if analysis_id and (answer is not None):
        st = _SESS.get(analysis_id)
        if not st:
            return jsonify({"error": "unknown_analysis_id"}), 400
        st["answers"].append(str(answer).strip())

    st = _SESS.get(analysis_id)
    if not st:
        return jsonify({"error": "missing_description"}), 400

    js = _call_llm_json(
        SYSTEM_ANALYST,
        USER_TEMPLATE.format(description=st["description"], answers=st["answers"])
    )

    # fallback if no LLM
    if js is None:
        if not st["answers"]:
            q = "What is your approximate budget and target timeline to launch?"
            st["questions"].append(q)
            return jsonify({
                "status": "needs_followup",
                "analysis_id": analysis_id,
                "question": q,
                "asked": st["questions"],
                "missing_fields": ["budget", "timeline"]
            })
        return jsonify(_finalize_payload(analysis_id, {
            "market_iq_score": 73,
            "component_scores": {
                "financial_health": 85,
                "operational_efficiency": 62,
                "market_position": 78,
                "execution_readiness": 67
            },
            "financial_impact": {},
            "key_insights": [
                "Strong financial fundamentals indicate a solid foundation.",
                "Operational efficiency gaps could reduce EBITDA flow-through by ~15%.",
                "Competitive positioning is solid; execution timeline needs optimization."
            ],
            "top_risks": [
                {"risk":"Extended time-to-market", "impact":"$450K delay", "mitigation":"Run testing in parallel; agile sprints"},
                {"risk":"Efficiency below benchmark", "impact":"$300K EBITDA reduction", "mitigation":"Lean methods; standardization"}
            ],
            "recommendations": [
                {"action":"Accelerate MVP", "expected_impact":"$450K revenue acceleration", "effort":"Medium", "timeline":"6-8 weeks"},
                {"action":"Ops improvements", "expected_impact":"15% EBITDA improvement", "effort":"High", "timeline":"3-6 months"}
            ]
        }))

    status = js.get("status")
    if status == "needs_followup":
        q = js.get("question") or "What is your budget and timeline?"
        if _SESS[analysis_id]["questions"] and q.strip() == _SESS[analysis_id]["questions"][-1]:
            q += " (please be specific)"
        _SESS[analysis_id]["questions"].append(q)
        return jsonify({
            "status": "needs_followup",
            "analysis_id": analysis_id,
            "question": q,
            "asked": _SESS[analysis_id]["questions"],
            "missing_fields": js.get("missing_fields", [])
        })

    payload = _finalize_payload(analysis_id, js)
    return jsonify(payload)

@market_iq_bp.route('/chat', methods=['POST'])
def chat():
    data = request.get_json(force=True) or {}
    message = data.get("message", "").strip()
    analysis_context = data.get("analysis_context") or {}
    analysis_id = data.get("analysis_id") or analysis_context.get("analysis_id")
    if not message:
        return jsonify({"error": "missing_message"}), 400

    context_summary = ""
    if analysis_context:
        try:
            context_summary = json.dumps({
                "score": analysis_context.get("market_iq_score"),
                "components": analysis_context.get("component_scores"),
                "risks": analysis_context.get("top_risks"),
                "recommendations": analysis_context.get("recommendations")
            }, ensure_ascii=False)
        except Exception:
            context_summary = ""

    client = _get_openai()
    if not client:
        return jsonify({"response": "Hereâ€™s a tactical next step: define owners & milestones for your top two recommendations and set a weekly KPI review. (Demo mode)"})


    system = (
        "You are MarketIQ, a concise operator/finance copilot. Use the provided analysis context. "
        "Give direct, actionable guidance (bullets welcomed). Avoid fluff."
    )
    user = f"User message: {message}\n\nAnalysis context (JSON): {context_summary}\n\nIf asked for plan, give concrete steps with owners, duration, and expected impact."

    resp = client.chat.completions.create(
        model=os.getenv("OPENAI_MODEL", "gpt-4o-mini"),
        temperature=0.2,
        messages=[{"role":"system","content":system},{"role":"user","content":user}],
    )
    content = resp.choices[0].message.content
    return jsonify({"response": content})
