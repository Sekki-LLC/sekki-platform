from flask import Blueprint, request, jsonify
import os, json, uuid, sqlite3
from datetime import datetime

market_iq_bp = Blueprint("market_iq", __name__, url_prefix="/api/market-iq")

# ---------- storage (SQLite, per-request connection) ----------
DB_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../market_iq.db"))

def _conn():
    con = sqlite3.connect(DB_PATH, check_same_thread=False)
    con.row_factory = sqlite3.Row
    return con

def _init_db():
    with _conn() as con:
        con.execute("""
        CREATE TABLE IF NOT EXISTS sessions (
          id TEXT PRIMARY KEY,
          description TEXT NOT NULL,
          status TEXT NOT NULL DEFAULT 'intake',
          created_at TEXT NOT NULL,
          questions TEXT NOT NULL,
          answers TEXT NOT NULL
        )""")
_init_db()

# ---------- LLM helpers (OpenAI optional) ----------
def _client():
    try:
        from openai import OpenAI
        return OpenAI()
    except Exception:
        return None

def _questions_fallback():
    return [
        "Briefly describe the product or initiative.",
        "Who is the target customer and geo?",
        "What’s the total budget (CapEx/OpEx split if applicable)?",
        "Target launch timeline and key milestones?",
        "Primary success KPIs (e.g., EBITDA, ARR, payback months)?",
        "Expected demand/market size and growth assumption?",
        "Pricing and margin target (gross margin %, ASP)?",
        "Go-to-market approach (channels, sales motion)?",
        "Key risks (supply, compliance, competition, staffing)?",
        "Operational plan (team, vendors, tooling, automation)?",
        "Regulatory or certification constraints?",
        "Top 3 unknowns that could change the outcome?",
        "What does success in 12 months look like?",
        "What tradeoffs are acceptable (time, scope, cost)?",
        "Anything else that would change the plan?"
    ]

def _llm_questions(description: str):
    client = _client()
    if not client:
        return _questions_fallback()
    sys = (
        "You create crisp intake questionnaires for business/market analysis. "
        "Return 12–18 short, specific questions that will let you estimate Market IQ, EBITDA at risk, "
        "ROI opportunities, execution readiness, and timeline risk. Output JSON: {\"questions\": [ ... ]} only."
    )
    user = f"Project description:\n{description}\n\nReturn JSON only."
    try:
        resp = client.chat.completions.create(
            model=os.getenv("OPENAI_MODEL", "gpt-4o-mini"),
            response_format={"type": "json_object"},
            temperature=0.2,
            messages=[{"role":"system","content":sys},{"role":"user","content":user}],
        )
        data = json.loads(resp.choices[0].message.content)
        q = [q for q in data.get("questions", []) if isinstance(q, str)]
        return q[:18] if q else _questions_fallback()
    except Exception:
        return _questions_fallback()

def _llm_finalize(description: str, qas: list[dict]):
    """Return a structured analysis. Always JSON."""
    client = _client()
    sys = (
        "You are a conservative business analyst. Produce a Market IQ score (0–100) and structured analysis. "
        "Return JSON ONLY with these fields: "
        "{market_iq_score:int, score_category:str, component_scores:{financial_health:int, operational_efficiency:int, "
        "market_position:int, execution_readiness:int}, financial_impact:{ebitda_at_risk:str, potential_loss:str, "
        "roi_opportunity:str, projected_ebitda:str, time_to_market_impact:str}, key_insights:[str], "
        "top_risks:[{risk,impact,mitigation}], recommendations:[{action,expected_impact,effort,timeline}]}"
    )
    user = json.dumps({
        "description": description,
        "qa": qas
    }, ensure_ascii=False)
    try:
        if not client:
            # If no LLM available, signal gracefully (frontend will show message instead of crashing)
            return {"error": "LLM_UNAVAILABLE"}
        resp = client.chat.completions.create(
            model=os.getenv("OPENAI_MODEL", "gpt-4o-mini"),
            response_format={"type": "json_object"},
            temperature=0.2,
            messages=[{"role":"system","content":sys},{"role":"user","content":user}],
        )
        return json.loads(resp.choices[0].message.content)
    except Exception as e:
        return {"error": f"LLM_ERROR: {type(e).__name__}"}

# ---------- helpers ----------
def _new_session(description: str):
    sid = "miq_" + uuid.uuid4().hex[:10]
    questions = _llm_questions(description)
    answers = []
    with _conn() as con:
        con.execute(
            "INSERT INTO sessions(id, description, status, created_at, questions, answers) VALUES(?,?,?,?,?,?)",
            (sid, description, "intake", datetime.utcnow().isoformat(),
             json.dumps(questions, ensure_ascii=False), json.dumps(answers, ensure_ascii=False))
        )
    return sid, questions, answers

def _load(sid: str):
    with _conn() as con:
        row = con.execute("SELECT * FROM sessions WHERE id=?", (sid,)).fetchone()
        return dict(row) if row else None

def _save_answers(sid: str, answers: list[str]):
    with _conn() as con:
        con.execute("UPDATE sessions SET answers=? WHERE id=?", (json.dumps(answers, ensure_ascii=False), sid))

def _complete(sid: str, payload: dict):
    with _conn() as con:
        con.execute("UPDATE sessions SET status='complete' WHERE id=?", (sid,))

# ---------- routes ----------
@market_iq_bp.route("/intake/start", methods=["POST"])
def intake_start():
    data = request.get_json(silent=True) or {}
    desc = data.get("description") or data.get("project_description")
    if not desc:
        return jsonify({"error":"missing description"}), 400
    sid, questions, _ = _new_session(desc)
    total = len(questions)
    return jsonify({
        "analysis_id": sid,
        "next_question": questions[0] if total else None,
        "progress": {"answered": 0, "total": total}
    })

@market_iq_bp.route("/intake", methods=["POST"])
def intake_step():
    data = request.get_json(silent=True) or {}
    sid = data.get("analysis_id")
    answer = (data.get("answer") or "").strip()
    if not sid or not answer:
        return jsonify({"error":"missing analysis_id or answer"}), 400
    sess = _load(sid)
    if not sess:
        return jsonify({"error":"invalid analysis_id"}), 404

    questions = json.loads(sess["questions"])
    answers = json.loads(sess["answers"])
    answers.append(answer)
    _save_answers(sid, answers)

    if len(answers) < len(questions):
        return jsonify({
            "analysis_id": sid,
            "next_question": questions[len(answers)],
            "progress": {"answered": len(answers), "total": len(questions)}
        })
    # finalize
    qas = [{"question": q, "answer": a} for q, a in zip(questions, answers)]
    final = _llm_finalize(sess["description"], qas)
    if "error" in final:
        return jsonify({"error": final["error"], "analysis_id": sid, "progress": {"answered": len(answers), "total": len(questions)}}), 503
    _complete(sid, final)
    final["analysis_id"] = sid
    return jsonify(final)

@market_iq_bp.route("/commit", methods=["POST"])
def commit():
    data = request.get_json(silent=True) or {}
    sid = data.get("analysis_id")
    if not sid:
        return jsonify({"error":"missing analysis_id"}), 400
    sess = _load(sid)
    if not sess:
        return jsonify({"error":"invalid analysis_id"}), 404
    questions = json.loads(sess["questions"])
    answers = json.loads(sess["answers"])
    qas = [{"question": q, "answer": a if i < len(answers) else ""} for i, q in enumerate(questions)]
    final = _llm_finalize(sess["description"], qas)
    if "error" in final:
        return jsonify({"error": final["error"], "analysis_id": sid}), 503
    _complete(sid, final)
    final["analysis_id"] = sid
    return jsonify(final)

# Compatibility: allow POST /analyze to act as start, step, or finalize.
@market_iq_bp.route("/analyze", methods=["POST"])
def analyze():
    data = request.get_json(silent=True) or {}
    # step
    if data.get("analysis_id") and data.get("answer"):
        return intake_step()
    # finalize
    if data.get("analysis_id") and data.get("finalize"):
        return commit()
    # start
    if data.get("description") or data.get("project_description"):
        # route to intake/start
        return intake_start()
    return jsonify({"error":"missing description or analysis_id"}), 400
