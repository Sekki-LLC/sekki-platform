from flask import Blueprint, request, jsonify, current_app
import os, json, sqlite3, uuid
from datetime import datetime
from contextlib import contextmanager
from dotenv import load_dotenv

# ----- env & OpenAI client -----
load_dotenv()
from openai import OpenAI
def _client():
    return OpenAI()

MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")

market_iq_bp = Blueprint("market_iq", __name__, url_prefix="/api/market-iq")
from app.miq_interview import interview_step, MIN_ANSWERS, CONFIDENCE_THRESHOLD

# ----- SQLite persistence -----
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
DB_PATH = os.getenv("MARKET_IQ_DB", os.path.join(BASE_DIR, "market_iq.db"))
os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)

def _dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

@contextmanager
def db():
    con = sqlite3.connect(DB_PATH, check_same_thread=False)
    con.row_factory = _dict_factory
    try:
        yield con
        con.commit()
    finally:
        con.close()

def init_db():
    with db() as con:
        con.execute("""
        CREATE TABLE IF NOT EXISTS sessions(
          id TEXT PRIMARY KEY,
          description TEXT NOT NULL,
          answers_json TEXT NOT NULL,
          last_field TEXT,
          last_question TEXT,
          total_q INTEGER NOT NULL,
          answered_q INTEGER NOT NULL,
          status TEXT NOT NULL,
          created_at TEXT NOT NULL
        )
        """)
init_db()

# ===== Adaptive intake configuration =====
# (We track fields but we DON'T hardcode the question text.)
REQUIRED_FIELDS = [
    "primary_goal",
    "project_type",
    "target_customer",
    "market_geography",
    "market_size",
    "budget_total",
    "runway_months",
    "timeline_target",
    "revenue_model",
    "current_stage",
    "team",
    "competitors",
    "gtm_channels",
    "unit_economics",
    "key_risks",
    "constraints",
]
TOTAL_Q = len(REQUIRED_FIELDS)

def _now():
    return datetime.utcnow().isoformat() + "Z"

def _load_session(con, sid):
    row = con.execute("SELECT * FROM sessions WHERE id=?", (sid,)).fetchone()
    if not row: return None
    row["answers"] = json.loads(row.get("answers_json") or "{}")
    return row

def _save_session(con, sess):
    data = dict(sess)
    data["answers_json"] = json.dumps(sess.get("answers", {}), ensure_ascii=False)
    cols = ("id","description","answers_json","last_field","last_question",
            "total_q","answered_q","status","created_at")
    vals = tuple(data.get(k) for k in cols)
    con.execute("""
      INSERT INTO sessions(id,description,answers_json,last_field,last_question,total_q,answered_q,status,created_at)
      VALUES(?,?,?,?,?,?,?,?,?)
      ON CONFLICT(id) DO UPDATE SET
        description=excluded.description,
        answers_json=excluded.answers_json,
        last_field=excluded.last_field,
        last_question=excluded.last_question,
        total_q=excluded.total_q,
        answered_q=excluded.answered_q,
        status=excluded.status
    """, vals)

def _score_with_llm(description, answers):
    sys = (
      "You are Market IQ. Score initiatives across finance, operations, market, execution. "
      "Output strict JSON:\n"
      "{"
      '"market_iq_score": int, "score_category": "Poor|Fair|Good|Strong|Excellent", '
      '"component_scores":{"financial_health":int,"operational_efficiency":int,"market_position":int,"execution_readiness":int},'
      '"financial_impact":{"ebitda_at_risk":str,"potential_loss":str,"roi_opportunity":str,"projected_ebitda":str,"time_to_market_impact":str},'
      '"key_insights":[str...],'
      '"top_risks":[{"risk":str,"impact":str,"mitigation":str}...],'
      '"recommendations":[{"action":str,"expected_impact":str,"effort":"Low|Medium|High","timeline":str}...]'
      "}"
    )
    user = json.dumps({"project_description": description, "answers": answers}, ensure_ascii=False)
    resp = _client().chat.completions.create(
        model=MODEL,
        temperature=0.2,
        response_format={"type":"json_object"},
        messages=[{"role":"system","content":sys},{"role":"user","content":user}]
    )
    return json.loads(resp.choices[0].message.content)

# Import adaptive helpers
from app.miq_qgen import propose_next_question, extract_fields

def _remaining_fields(answers: dict):
    return [f for f in REQUIRED_FIELDS if f not in (answers or {})]

@market_iq_bp.route("/intake/start", methods=["POST"])
def intake_start():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or data.get("project_description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400

        sid = "miq_" + uuid.uuid4().hex[:10]
        answers = {}

        # Ask the first best question (LLM chooses which field to fill first)
        rem = _remaining_fields(answers)
        nxt = propose_next_question(description, answers, rem)

        with db() as con:
            sess = {
                "id": sid, "description": description, "answers": answers,
                "last_field": nxt["field"], "last_question": nxt["question"],
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now()
            }
            _save_session(con, sess)

        return jsonify({
            "analysis_id": sid,
            "field": nxt["field"],
            "question": nxt["question"],
            "answered": 0,
            "total_questions": TOTAL_Q
        })
    except Exception as e:
        return jsonify({"error":"intake_start_failed","details":str(e)}), 500

@market_iq_bp.route("/intake/answer", methods=["POST"])
def intake_answer():
    try:
        data = request.get_json(force=True) or {}
        sid = data.get("analysis_id")
        user_answer = (data.get("answer") or "").strip()
        # Optional: accept legacy {field, answer}
        legacy_field = data.get("field")

        if not sid or not user_answer:
            return jsonify({"error":"missing_params"}), 400

        with db() as con:
            sess = _load_session(con, sid)
            if not sess:
                return jsonify({"error":"unknown_analysis_id"}), 404

            answers = sess["answers"]

            # If caller sent explicit field, record that first
            if legacy_field and legacy_field not in answers:
                answers[legacy_field] = user_answer
                sess["answered_q"] += 1

            # What is still missing?
            remaining = [f for f,_ in QUESTIONS if f not in answers]

            # Ask the interviewer to extract & decide next move
            try:
                step = interview_step(
                description=sess["description"],
                answers=answers,
                latest_text=user_answer,
                remaining_fields=remaining
            )
        except Exception as _e:
            try:
                current_app.logger.exception("interview_step failed: %s", _e)
            except Exception:
                pass
            step = {
                "added": {},
                "next_field": (remaining[0] if remaining else None),
                "next_question": (dict(QUESTIONS).get(remaining[0]) if remaining else None) if remaining else None,
                "finalize": False,
                "confidence": 0.0,
            }

            # Merge inferred answers (capped by MAX_AUTOFILL)
            added = 0
            for k,v in (step.get("added") or {}).items():
                if k not in answers:
                    answers[k] = v
                    added += 1
            sess["answered_q"] += added

            # Recompute remaining after merge
            remaining = [f for f,_ in QUESTIONS if f not in answers]

            # Decide if we should finalize
            if step.get("finalize") or sess["answered_q"] >= sess["total_q"] or sess["answered_q"] >= MIN_ANSWERS:
                try:
                    analysis = _score_with_llm(sess["description"], answers)
                except Exception as e:
                    return jsonify({"error":"llm_unavailable","details":str(e)}), 503

                sess["status"] = "complete"
                _save_session(con, sess)
                analysis["analysis_id"] = sid
                analysis["timestamp"] = _now()
                analysis["answers"] = answers
                analysis["description"] = sess["description"]
                return jsonify({"complete": True, "analysis_result": analysis})

            # Otherwise, ask one next, conversational question
            next_field = step.get("next_field") or (remaining[0] if remaining else None)
            next_q = step.get("next_question") or (dict(QUESTIONS).get(next_field) if next_field else None)
            sess["last_field"] = next_field
            sess["last_question"] = next_q
            _save_session(con, sess)

            return jsonify({
                "complete": False,
                "next_field": next_field,
                "next_question": next_q,
                "answered": sess["answered_q"],
                "total_questions": sess["total_q"]
            })
    except Exception as e:
        return jsonify({"error":"intake_answer_failed","details":str(e)}), 500

@market_iq_bp.route("/scenario", methods=["POST"])
def scenario():
    try:
        data = request.get_json(force=True) or {}
        base = data.get("analysis_result") or {}
        changes = data.get("changes") or {}
        description = base.get("description") or "Scenario"
        answers = base.get("answers") or {}
        answers.update(changes)
        try:
            analysis = _score_with_llm(description, answers)
        except Exception as e:
            return jsonify({"error":"llm_unavailable","details":str(e)}), 503
        analysis["scenario_from"] = base.get("analysis_id")
        analysis["analysis_id"] = "miq_" + uuid.uuid4().hex[:10]
        analysis["timestamp"] = _now()
        analysis["answers"] = answers
        analysis["description"] = description
        return jsonify(analysis)
    except Exception as e:
        return jsonify({"error":"scenario_failed","details":str(e)}), 500

@market_iq_bp.route("/analyze", methods=["POST"])
def analyze_shim():
    try:
        data = request.get_json(force=True) or {}
        description = (data.get("description") or data.get("project_description") or "").strip()
        if not description:
            return jsonify({"error":"missing_description"}), 400
        sid = "miq_" + uuid.uuid4().hex[:10]
        with db() as con:
            _save_session(con, {
                "id": sid, "description": description, "answers": {},
                "last_field": None, "last_question": None,
                "total_q": TOTAL_Q, "answered_q": 0, "status": "intake",
                "created_at": _now()
            })
        # Keep behavior aligned with start: immediately return first question
        from app.miq_qgen import propose_next_question
        nxt = propose_next_question(description, {}, REQUIRED_FIELDS)
        with db() as con:
            sess = _load_session(con, sid)
            sess["last_field"] = nxt["field"]
            sess["last_question"] = nxt["question"]
            _save_session(con, sess)
        return jsonify({
            "analysis_id": sid,
            "field": nxt["field"],
            "question": nxt["question"],
            "answered": 0,
            "total_questions": TOTAL_Q
        })
    except Exception as e:
        return jsonify({"error":"analyze_failed","details":str(e)}), 500
